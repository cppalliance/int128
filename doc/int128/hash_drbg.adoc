////
Copyright 2024 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#hash_drgb]
:idprefix: hash_drbg_

= Hash-Based Deterministic Random Bit Generators

== Overview
Hash-based Deterministic Random Bit Generators (DRBGs) are cryptographic algorithms that produce a sequence of bits that appear random, but are deterministically generated from an initial seed.
These generators are crucial in cryptographic applications where predictability must be avoided and reproducibility is required given the same input.
The family of hash DRBGs implemented here leverages cryptographic hash functions to ensure security and randomness properties.
The design adheres to standards such as NIST SP 800-90A, which specifies requirements for deterministic random bit generators using hash functions.

== Security Considerations
The security of hash DRBGs is primarily dependent on the cryptographic strength of the underlying hash function used. The library supports several popular hash functions from the Boost.Crypt library, including SHA-256, SHA-512, and others.Users are encouraged to choose a hash function that meets their security requirements
Key security considerations include:

- Seed Quality: The initial seed must be sufficiently random and unpredictable. A poor quality seed can compromise the security of the generated bit sequence.
- Nonce Source: Ensure that you are inputting a nonce when instantiating the generator.
- Entropy Source: Ensure that the entropy source used to generate the seed is reliable and provides adequate entropy.
- Re-seeding: Regular reseeding with new entropy is recommended to maintain security, especially in long-running applications.

=== Prediction Resistance

Prediction resistance refers to the ability of a random number generator to resist attacks that attempt to predict future outputs based on past outputs.
A cryptographically secure RNG should be designed in such a way that even if an attacker has observed all previous outputs, they cannot reliably predict future outputs.

See NIST SP 800-90A if you are concerned about approved sources of entropy and nonces.

== Reference

[source, c++]
----
namespace boost {
namespace crypt {

namespace drbg {

template <bool prediction_resistance>
using sha1_hash_drbg_t = hash_drbg<sha1_hasher, 128U, 160U, prediction_resistance>;

} // namespace drbg

BOOST_CRYPT_EXPORT using sha1_hash_drbg = drbg::sha1_hash_drbg_t<false>;
BOOST_CRYPT_EXPORT using sha1_hash_drbg_pr = drbg::sha1_hash_drbg_t<true>;

// So on for each hasher available with the correct presets

namespace drbg {

// Max hasher security is defined in NIST SP 800-57 Table 3:
// See: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf
//
// 112: None
// 128: SHA-1
// 192: SHA-224, SHA-512/224, SHA3-224
// 256: SHA-256, SHA-512/256, SHA-384, SHA-512, SHA3-256, SHA3-384, SHA3-512
//
// Outlen is defined in NIST SP 800-90A Rev 1 Section 10.1 table 2
// 160: SHA-1
// 224: SHA-224, SHA-512/224
// 256: SHA-256, SHA-512/256
// 384: SHA-384
// 512: SHA-512
template <typename HasherType, compat:size_t max_hasher_security, compat::size_t outlen, bool prediction_resistance>
class hash_drbg
{
public:

public:

    BOOST_CRYPT_GPU_ENABLED_CONSTEXPR hash_drbg() noexcept = default;

    BOOST_CRYPT_GPU_ENABLED_CONSTEXPR ~hash_drbg() noexcept;

    template <compat::size_t Extent1,
              compat::size_t Extent2 = 0U,
              compat::size_t Extent3 = 0U>
    BOOST_CRYPT_GPU_ENABLED_CONSTEXPR auto init(
        compat::span<const compat::byte, Extent1> entropy,
        compat::span<const compat::byte, Extent2> nonce = compat::span<const compat::byte, 0>{},
        compat::span<const compat::byte, Extent3> personalization = compat::span<const compat::byte, 0>{}) noexcept -> state;

    template <concepts::sized_range SizedRange1,
              concepts::sized_range SizedRange2,
              concepts::sized_range SizedRange3 = compat::span<const compat::byte, 0U>>
    BOOST_CRYPT_GPU_ENABLED auto init(
        SizedRange1&& entropy,
        SizedRange2&& nonce = compat::span<const compat::byte, 0U> {},
        SizedRange3&& personalization = compat::span<const compat::byte, 0U> {}) noexcept -> state;

    template <compat::size_t Extent1,
              compat::size_t Extent2 = 0U>
    BOOST_CRYPT_GPU_ENABLED_CONSTEXPR auto reseed(
        compat::span<const compat::byte, Extent1> entropy,
        compat::span<const compat::byte, Extent2> additional_input = compat::span<const compat::byte, 0>{}) noexcept -> state;

    template <concepts::sized_range SizedRange1,
              concepts::sized_range SizedRange2 = compat::span<const compat::byte, 0U>>
    BOOST_CRYPT_GPU_ENABLED auto reseed(
        SizedRange1&& entropy,
        SizedRange2&& additional_input = compat::span<const compat::byte, 0U> {}) noexcept -> state;

    template <compat::size_t Extent1,
              compat::size_t Extent2 = 0U,
              compat::size_t Extent3 = 0U>
    BOOST_CRYPT_GPU_ENABLED_CONSTEXPR auto generate(
        compat::span<compat::byte, Extent1> return_data, compat::size_t requested_bits,
        compat::span<const compat::byte, Extent2> additional_data1 = compat::span<const compat::byte, 0U> {},
        [[maybe_unused]] compat::span<const compat::byte, Extent3> additional_data2 = compat::span<const compat::byte, 0U> {}) noexcept -> state;

    template <concepts::sized_range SizedRange1,
              concepts::sized_range SizedRange2 = compat::span<const compat::byte, 0U>,
              concepts::sized_range SizedRange3 = compat::span<const compat::byte, 0U>>
    BOOST_CRYPT_GPU_ENABLED auto generate(
        SizedRange1&& return_data, compat::size_t requested_bits,
        SizedRange2&& additional_data1 = compat::span<const compat::byte, 0U>{},
        [[maybe_unused]] SizedRange3&& additional_data2 = compat::span<const compat::byte, 0U>{}) noexcept -> state;
};

} // namespace drbg
} // namespace crypt
} // namespace boost

----

IMPORTANT: In the generate methods if you are using a prediction resistant DRBG you are required at add additional entropy as `addtional_data1` and optionally add personalization with `additional_data2`. These are both optional with a non-prediction resistant DRBG.
