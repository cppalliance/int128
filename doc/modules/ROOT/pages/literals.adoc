////
Copyright 2025 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#literals]
= Literals
:idprefix: literals_

The following literals and macros are provided for convenient construction of the types provided in the library.

[source, c++]
----
#include <boost/int128/literals.hpp>

namespace boost {
namespace int128 {
namespace literals {

constexpr uint128_t operator ""_u128(const char* str) noexcept;

constexpr uint128_t operator ""_U128(const char* str) noexcept;

constexpr uint128_t operator ""_u128(const char* str, std::size_t len) noexcept;

constexpr uint128_t operator ""_U128(const char* str, std::size_t len) noexcept;

constexpr uint128_t operator ""_u128(unsigned long long v) noexcept;

constexpr uint128_t operator ""_U128(unsigned long long v) noexcept;

constexpr int128_t operator ""_i128(const char* str) noexcept;

constexpr int128_t operator ""_I128(const char* str) noexcept;

constexpr int128_t operator ""_i128(unsigned long long v) noexcept;

constexpr int128_t operator ""_I128(unsigned long long v) noexcept;

constexpr int128_t operator ""_i128(const char* str, std::size_t len) noexcept;

constexpr int128_t operator ""_I128(const char* str, std::size_t len) noexcept;

} // namespace literals
} // namespace int128
} // namespace boost

#define BOOST_INT128_UINT128_C(x) ...
#define BOOST_INT128_INT128_C(x) ...

----

The macros at the end allow you to write out a 128-bit number like you would with say `UINT64_C` without having to add quotes.

See the xref:examples.adoc#examples_construction[construction examples] for usage demonstrations of both literals and macros.
